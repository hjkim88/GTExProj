# Perform non-paired or paired limma fitting for a gene expression dataset and
# for random sample permutations
#
# ARGUMENTS:
# * dset:		A numeric matrix where rows are genes and columns are samples and where
#		dset[i, j] is the normalized expression (in log-scale) of the i-th gene on
#		the j-th sample. colnames(dset) provides the sample names and rownames(dset)
#		contains the genes names (either entrez ids or gene symbols).
# * annot:		A vector of length ncol(dset) where names(annot) = colnames(dset) and 
#		where length(unique(annot)) = 2. It provides annotations for the samples in
#		dset such that each sample belongs to EXACTLY one of  two categories: either 
#		unique(annot)[1] or unique(annot)[2].
# * paired:		If not NULL, this means that the analysis is paired. In that case, the
#		value of this argument is a vector of length ncol(dset), such that:
#		- names(paired) = colnames(dset)
#		- Each value S in "paired" represents a subject id and there are EXACTLY two
#		  entries in "paired" whose value is S. Further, if paired[i] == paired[j] == S,
#		  then annot[names(paired)[i]] != annot[names(paired)[j]]. In other words, two
#		  samples coming from the same subject MUST be annotated differently. The code 
#		  of the function below must check that these contraints hold and, if not, stop
#		  using the the message "Variable 'paired' not constructed properly."
#		If paired == NULL, then the analysis in not paired.
# * reps:		Positive integer, indicating the number of random sample shufflings to
#		perform, see below for details.
# * seed:   Integer. will be provided to random shuffle process for reproductivity.
#   if the same seed is used, we can regenerate the same random results.
# 
# The method utilizes limma to perform differential gene expression analysis with either 
# a paired on non-paired design, depending on the value of the argument "paired". In 
# either case, samples belong in one of two classes, as specified in "annot", and the
# cotrast involving these two classes will be reported. In addition to performing the 
# DE analysis on dset, the function will also perform shuffled DE analyses (the number
# of such analyses to be peformed is specified by the value of the argument "reps"). 
# Each such analysis involves randonly permuting samples anntations as follows:
#	- For non-paired analyses, simply randomly shuffle the class assignemnts in "annot".
#	- For paired analyses, randomly shuffle subject id assignments for the samples within
#	  each annotation category. I.e., first take the samples annotated as unique(annot)[1]
#	  and shuffle subject ids in "paired". And then repeat the shuffling process for samples 
#	  annotated as unique(annot)[2]
#
# RETURN VALUE
# The method returns a list L with two entries:
# * L[[1]]: 	this is a data frame of dimensions nrow(dset) x 2, where colnames(L[[1]]) = 
#		c("ttest", "pval") and rownames(L[[1]]) = rownames(dset). Each row in L[[1]] 
#		corresponds to a gene and contains the t-test statistic and associated 
#		UNADJUSTED p-value generated by limma for that gene.
# * L[[2]]:		this is a list with "reps" entries where each entry corresponds to a random
#		shuffling and contains the results of limmma for that shuffling. For the i-th
#		shuffling, L[[2]][[i]] is a data frame with the same structure as L[[1]].
fitWithPermutations <- function(dset, annot, paired = NULL, reps = 1000, seed=1234){
	
  ### load library
  if(!require(ArgumentCheck)) {
    install.packages("ArgumentCheck")
    library(ArgumentCheck)
  }
  
  ### argument checking
  check <- ArgumentCheck::newArgCheck()
  if(is.null(dset)) {
    ArgumentCheck::addError(
      msg = "[dset] should be provided. A numeric matrix where rows are genes and columns are samples and where dset[i, j] is the normalized expression (in log-scale) of the i-th gene on the j-th sample.",
      argcheck = check
    )
  }
  if((!is.null(dset)) && (!is.numeric(dset))) {
    ArgumentCheck::addError(
      msg = "[dset] should be a numeric matrix.",
      argcheck = check
    )
  }
  if(is.null(annot)) {
    ArgumentCheck::addError(
      msg = "[annot] should be provided. A vector of length ncol(dset) that provides annotations for the samples in dset such that each sample belongs to EXACTLY one of  two categories: either unique(annot)[1] or unique(annot)[2].",
      argcheck = check
    )
  }
  if((!is.null(annot)) && (!identical(names(annot), colnames(dset)))) {
    ArgumentCheck::addError(
      msg = "[annot] names(annot) should be equal to colnames(dset).",
      argcheck = check
    )
  }
  if((!is.null(annot)) && (length(unique(annot)) != 2)) {
    ArgumentCheck::addError(
      msg = "[annot] length(unique(annot)) should be 2. There should be only two classes.",
      argcheck = check
    )
  }
  if((!is.null(paired)) && (!identical(names(paired), colnames(dset)))) {
    ArgumentCheck::addError(
      msg = "[paired] names(paired) should be equal to colnames(dset).",
      argcheck = check
    )
  }
  if(!is.null(paired)) {
    unique_paired <- unique(paired)
    isProper=TRUE
    for(i in 1:length(unique_paired)) {
      temp <- annot[names(paired)[which(paired == unique_paired[i])]]
      if((length(temp) != 2) || (length(unique(temp)) != 2)) {
        isProper=FALSE
        break
      }
    }
    if(!isProper) {
      ArgumentCheck::addError(
        msg = "[paired] Variable [paired] not constructed properly. Each value S in [paired] represents a subject id and there are EXACTLY two entries in [paired] whose value is S. Further, if paired[i] == paired[j] == S, then annot[names(paired)[i]] != annot[names(paired)[j]]. In other words, two samples coming from the same subject MUST be annotated differently.",
        argcheck = check
      )
    }
  }
  if(is.null(reps)) {
    ArgumentCheck::addError(
      msg = "[reps] should be provided. A positive integer, indicating the number of random sample shufflings to perform.",
      argcheck = check
    )
  }
  if((!is.null(reps)) && (reps < 1)) {
    ArgumentCheck::addError(
      msg = "[reps] should be positive.",
      argcheck = check
    )
  }
  if((!is.null(reps)) && (round(reps) != reps)) {
    ArgumentCheck::addError(
      msg = "[reps] should be a positive INTEGER.",
      argcheck = check
    )
  }
  if(is.null(seed)) {
    ArgumentCheck::addError(
      msg = "[seed] should be provided. A integer that will be provided to random shuffle process for reproductivity.",
      argcheck = check
    )
  }
  if((!is.null(seed)) && (round(seed) != seed)) {
    ArgumentCheck::addError(
      msg = "[seed] should be an INTEGER.",
      argcheck = check
    )
  }
  ArgumentCheck::finishArgCheck(check)
  
  ### A function to perform repetitive DE analysis with limma
  limmaWithComparisons <- function(normCnt, grp, exp_class, ctrl_class, bat_eff=NULL) {
    
    ### load library
    if(!require(limma)) {
      source("https://bioconductor.org/biocLite.R")
      biocLite("limma")
      library(limma)
    }
    
    ### make a design matrix for DE analysis
    sampleType <- relevel(as.factor(grp), ref = ctrl_class)
    if(is.null(bat_eff)) {
      design <- model.matrix(~0+sampleType)
      colnames(design) <- levels(sampleType)
    } else {
      bat_eff <- as.factor(bat_eff)
      design <- model.matrix(~0+sampleType+bat_eff)
      colnames(design) <- c(levels(sampleType), levels(bat_eff)[-1])
    }
    
    ### fir the linear model
    fit <- lmFit(normCnt, design)
    
    ### extract specific comparison of interest
    contrastMat <- makeContrasts(contrasts=paste(exp_class,ctrl_class,sep="-"), levels=design)
    
    ### fit the contrasts
    fit2 <- contrasts.fit(fit, contrastMat)
    fit2 <- eBayes(fit2)
    
    ### get the differentially expressed genes
    result <- topTable(fit2, adjust.method="BH", number=Inf)
    
    ### order based on adj.p.val
    result <- result[order(result$adj.P.Val),]
    
    return(result)
  }
  
  ### DE analysis with limma
  unique_annot <- unique(annot)
  if(is.null(paired)) {
    ### unpaired
    deresult <- limmaWithComparisons(dset, annot, unique_annot[1], unique_annot[2])
  } else {
    ### paired
    deresult <- limmaWithComparisons(dset, annot, unique_annot[1], unique_annot[2], paired)
  }
  
  ### create an empty result list
  L <- list()
  
  ### fill L[[1]] out
  L[[1]] <- data.frame(ttest=deresult[rownames(dset), "t"], pval=deresult[rownames(dset), "P.Value"])
  rownames(L[[1]]) <- rownames(dset)
  
  ### random shuffle and DE analysis for "reps" times
  L[[2]] <- list()
  set.seed(seed)
  if(is.null(paired)) {
    ### iteratively perform it for "reps" times
    for(i in 1:reps) {
      ### randomly shuffle the [annot]
      annot <- annot[sample(length(annot), length(annot))]
      names(annot) <- colnames(dset)
      
      ### DE analysis with limma - unpaired
      deresult <- limmaWithComparisons(dset, annot, unique_annot[1], unique_annot[2])
      
      ### fill out the list
      L[[2]][[i]] <- data.frame(ttest=deresult[rownames(dset), "t"], pval=deresult[rownames(dset), "P.Value"])
      rownames(L[[2]][[i]]) <- rownames(dset)
    }
  } else {
    ### get indicies of unique annots
    idx1 <- which(annot == unique_annot[1])
    idx2 <- which(annot == unique_annot[2])
    
    ### iteratively perform it for "reps" times
    for(i in 1:reps) {
      ### randomly shuffle the [paired]
      paired[idx1] <- paired[sample(idx1, length(idx1))]
      paired[idx2] <- paired[sample(idx2, length(idx2))]
      names(paired) <- colnames(dset)
      
      ### DE analysis with limma - paired
      deresult <- limmaWithComparisons(dset, annot, unique_annot[1], unique_annot[2], paired)
      
      ### fill out the list
      L[[2]][[i]] <- data.frame(ttest=deresult[rownames(dset), "t"], pval=deresult[rownames(dset), "P.Value"])
      rownames(L[[2]][[i]]) <- rownames(dset)
    }
  }
  
  return(L)
}
